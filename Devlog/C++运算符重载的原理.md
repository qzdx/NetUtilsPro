# C++ 运算符重载详解

## 一、成员函数重载（可修改类）
> 适用于能够修改类定义的场景

### 1.1 基本原理
当执行 `A3 = A2 + A1` 时，实际调用的是：
```cpp
A2.operator+(A1)
```

### 1.2 特性说明
- ⚠️ 只能有一个参数（隐式包含左操作数）
- 🔄 返回对象实例（可返回临时对象）
- 📌 作为类成员函数实现

### 1.3 示例代码
```cpp
class A {
public:
    A operator+(const A& other) {
        // 实现加法逻辑
        return A();
    }
};
```

## 二、友元函数重载（不可修改类）
> 适用于无法修改类定义的场景（如标准库容器）

### 2.1 典型场景
```cpp
cout << obj;  // 实际调用 operator<< 函数
```

### 2.2 参数结构
```cpp
operator<<(ostream& os, const A& obj)
```
- 📌 需要两个参数：输出流对象和操作数
- 📌 通常使用引用传递避免复制开销
- ⚠️ 必须声明为友元函数

### 2.3 为什么需要引用？
| 场景 | 问题 | 解决方案 |
|------|------|----------|
| 输出流复制 | 流对象复制导致性能损耗 | 使用引用传递 |
| 对象复制 | 大对象复制造成内存浪费 | 使用常量引用 |

## 三、关键区别对比
| 特征        | 成员函数重载       | 友元函数重载         |
|-------------|--------------------|----------------------|
| 定义位置    | 类内部             | 类外部               |
| 参数数量    | 1个（隐式包含左操作数） | 2个（显式传递）      |
| 访问权限    | 类成员函数         | 需要声明为友元       |
| 对象复制    | 无                 | 可通过引用避免       |
| 适用场景    | 自定义类型运算     | 标准库/第三方库扩展  |

